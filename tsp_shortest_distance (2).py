# -*- coding: utf-8 -*-
"""TSP shortest distance.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1fl5HPJnezEOqDZN2GI9U6NcrNAQEkwnC
"""

import numpy as np

path_distance =lambda r,c:np.sum([np.linalg.norm(c[r[p]]-c[r[p-1]]) for p in range(len(r))])

import numpy as np


path_distance = lambda r,c: np.sum([np.linalg.norm(c[r[p]]-c[r[p-1]]) for p in range(len(r))])



two_opt_swap = lambda r,i,k: np.concatenate((r[0:i],r[k:-len(r)+i-1:-1],r[k+1:len(r)]))

def two_opt(cities,improvement_threshold): # 2-opt Algorithm adapted from https://en.wikipedia.org/wiki/2-opt
    route = np.arange(cities.shape[0]) # Make an array of row numbers corresponding to cities.
    improvement_factor = 1 # Initialize the improvement factor.
    best_distance = path_distance(route,cities) # Calculate the distance of the initial path.
    
    while improvement_factor > improvement_threshold: # If the route is still improving, keep going!
        distance_to_beat = best_distance # Record the distance at the beginning of the loop.
        
        for swap_first in range(1,len(route)-2): # From each city except the first and last,
            for swap_last in range(swap_first+1,len(route)): # to each of the cities following,
                new_route = two_opt_swap(route,swap_first,swap_last) # try reversing the order of these cities
                new_distance = path_distance(new_route,cities) # and check the total distance with this modification.
                
                if new_distance < best_distance: # If the path distance is an improvement,
                    route = new_route # make this the accepted best route
                    best_distance = new_distance # and update the distance corresponding to this route.
        improvement_factor = 1 - best_distance/distance_to_beat # Calculate how much the route has improved.
    return route # When the route is no longer improving substantially, stop searching and return the route.

from google.colab import files
uploaded = files.upload()

import pandas as pd
cities2=pd.read_excel("/content/Cities.xlsx")
cities2.head(10)

from math import radians,cos,sin

lat = cities2['Lat'].map(radians)
lon = cities2['Long'].map(radians)
x = lon.map(cos)*lat.map(cos)*6371
y= lon.map(cos)*lat.map(sin)*6371


cities2["lat_radians"] = lat
cities2["lon_radians"] = lon
cities2["x"] = x
cities2["y"] = y
cities2.head()

cities = cities2.drop(["City", "Lat","Long", "Unnamed: 3", "Unnamed: 4","lat_radians", "lon_radians"], 1)
cities.head(6)

df = cities.copy()

from sklearn.preprocessing import MinMaxScaler
scaler = MinMaxScaler(feature_range=(0, 100), copy=True)
scaled_df = scaler.fit_transform(df)
scaled_df = pd.DataFrame(scaled_df, columns=['x1', 'x2'])

cities = np.asarray(cities)

scaled = np.asarray(scaled_df)

route = two_opt(scaled,0.001)
route

cities2.head(10)

# import matplotlib.pyplot as plt
# # Reorder the cities matrix by route order in a new matrix for plotting.
# new_cities_order = np.concatenate((np.array([scaled[route[i]] for i in range(len(route))]),np.array([scaled[0]])))
# # Plot the cities.
# plt.scatter(scaled[:,0],scaled[:,1])

# # Plot the path.
# plt.plot(new_cities_order[:,0],new_cities_order[:,1])
# plt.show()
# # Print the route as row numbers and the total distance travelled by the path.
# print("Route: " + str(route) + "\n\nDistance_scaled: " + str(path_distance(route,scaled)))

Distance_km = path_distance(route,scaled) * 53.31
Distance_km

order = pd.DataFrame(route, columns=["index"])
cities2["index"] = cities2.index
cities2
travel=order.merge(cities2, on = "index")

"""###############   Django #######################"""

start= travel[0:1]
loop = travel.append(start)
loop =loop.drop(["Unnamed: 3", "Unnamed: 4"], 1)
loop

"""##################################"""

loop.plot(kind="line", x="Long", y="Lat")

tsp = loop[["City","Lat", "Long"]]

tsp.to_csv('tsp9.csv', index=False)

from google.colab import files
files.download("tsp9.csv")

import pandas as pd
import io

from google.colab import files
uploaded = files.upload()

import pandas as pd
df=pd.read_csv("tsp9.csv")
df.head(10)

#add markers




import folium
from folium.plugins import MarkerCluster
import plotly.express as px

# set up the chart from the df dataFrame


# fit the map to surround the points
# fig.update_geos(fitbounds="locations", showcountries = True)

# add title


# center to the mean of all points
m = folium.Map(location=df[["Lat", "Long"]].mean().to_list(), zoom_start=2)

# if the points are too close to each other, cluster them, create a cluster overlay with MarkerCluster
marker_cluster = MarkerCluster().add_to(m)

# draw the markers and assign popup and hover texts
# add the markers the the cluster layers so that they are automatically clustered
for i,r in df.iterrows():
    location = (r["Lat"], r["Long"])
    folium.Marker(location=location,
                      popup = r['City'],
                      tooltip=r['City'])\
    .add_to(marker_cluster)
folium.PolyLine(locations=location,weight=5,colors='red').add_to(marker_cluster)

# display the map
m

!pip install gpxpy



